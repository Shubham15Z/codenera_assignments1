1. Define polymorphism and explain its types in Java.
Ans:
	Polymorphism is one of the main pilers of the OOPs.
	Polymorphism means an ability of object to take multiple forms.
	There are two types of polymorphism:
	1) Compile time polymorphism or Static polymorphism.
	2) Runtime polymorphism or Dynamic Polymorphism.

	1. Compile time Polymorphism:
		This can be achieved through method overloading.
		It is handled by Compiler.
		Method overloading can be achieved through
		1) Class should be same
		2) Method name should be same
		3) Parameters should be different
			i.e. either type, number or sequence of parameters should be different.
	2. Runtime Polymorphism:
		This can be achieved through method overriding.
		It is handled by JVM.
		Method overriding can be achieved through 
		1) Class should be different.
		2) Method name should be same.
		3) Parameters should be same
			i.e. either type, number or sequence of parameters should be same.

------------------------------------------------------------------------------------------------------------------

2. How does polymorphism enhance flexibility and extensibility in code?
Ans:
	1) Flexibility:
		Polymorphism enables writing code that can work with objects of different classes through a common class or interface. 
		This means the same method call can execute different behaviors depending on the object it is acting upon.
		The code does not need to know the exact type of object it is dealing with.
		It allows dynamic method invocation (method overriding), enabling runtime decision-making.
Ex:

class Animal 
{
    void makeSound() 
    {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal 
{
    void makeSound() 
    {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal 
{
    void makeSound()
    {
        System.out.println("Cat meows");
    }
}

public class Main 
{
    public static void main(String[] args) 
   {
        Animal myAnimal = new Dog();  
        myAnimal.makeSound();         // Output: Dog barks

        myAnimal = new Cat();
        myAnimal.makeSound();         // Output: Cat meows
    }
}

Here in above example, the makeSound() method is invoked on different subclasses without modifying the main program. 
This allows handling different behaviors seamlessly.
This is also know as "upcasting" or dynamic method dispatch.

	2) Extensibility:
		With polymorphism, new functionality can be added without modifying existing code. 
		This adheres to the Open/Closed Principle (OCP) from SOLID principles, where a class should be open for extension but closed for 			modification.

	Example: Adding a New Animal Without Changing Existing Code
		 If we introduce a new Cow class, the existing code remains unchanged:

class Cow extends Animal 
{
    void makeSound() 
    {
        System.out.println("Cow moos");
    }
}

public class Main {
    public static void main(String[] args) 
    {
        Animal myAnimal = new Cow();
        myAnimal.makeSound();  // Output: Cow moos
    }
}


Real-World Example of Polymorphism in Java
Scenario: Payment Processing System
Imagine you are developing an e-commerce platform that supports multiple payment methods like Credit Card, PayPal, and UPI. 
Instead of writing separate code for each payment method, we can use polymorphism to define a common interface and let 
different payment types provide their own implementations.

---------------------------------------------------------------------------------------------------------------------
	
 3. Explain the difference between compile-time and runtime polymorphism.
Ans:
			Compile Time Polymorphism						Run time Polymorphism

1)	Multiple methods with the same name but different parameter lists	A subclass provides a specific implementation of a method already  
	in the same class.							defined in its superclass.
2)	In Compile time Polymorphism, the call is resolved by the compiler.	In Run time Polymorphism, the call is not resolved by the compiler.
3)	It is also known as Static binding or Early binding.			It is also known as Dynamic binding or Late binding.
4)	It is achieved by method overloading					It is achieved by method overriding.
5)	It provides fast execution because the method that needs to be		It provides slow execution as compare to early binding because
	executed is known early at the compile time.	 			the method that needs to be executed is known at the runtime.
6)	Compile time polymorphism is less flexible as all things execute	Run time polymorphism is more flexible as all things
	at compile time.	 						execute at run time.
7)	Inheritance is not involved. 						Inheritance is involved.


-----------------------------------------------------------------------------------------------------------------------


4. Discuss the concept of method overloading with examples.
Ans:
	Method overloading is a feature in Java that allows multiple methods in the same class to have the same name 
	but different parameter lists. 
	The compiler differentiates these methods based on the number, type, or sequence of parameters.

	It is an example of Compile-Time Polymorphism.
	The return type does not determine method overloading.
	It helps improve code readability and reusability.

	To achieve method overloading we should take care of below rules:
	-Methods should be present in same class.
	-Methods should have the same name 
	-Methods should have different parameter lists.
		Number of parameters
		Type of parameters
		Order of parameters
	Return type alone cannot distinguish methods.

Examples:
1) Methods with different number of parameters:

class MathOperations 
{
    int add(int a, int b) 
    {
        return a + b;
    }

    int add(int a, int b, int c) {
        return a + b + c;
    }
}

public class Main 
{
    public static void main(String[] args) 
    {
        MathOperations math = new MathOperations();

        System.out.println(math.add(5, 10));     // Calls method with 2 parameters
        System.out.println(math.add(5, 10, 15)); // Calls method with 3 parameters
    }
}


2) Method with different type of parameters

class MathOperations 
{
    int multiply(int a, int b) 
    {
        return a * b;
    }

    double multiply(double a, double b) 
    {
        return a * b;
    }
}

public class Main 
{
    public static void main(String[] args) 
    {
        MathOperations math = new MathOperations();

        System.out.println(math.multiply(5, 10));      // Calls int version
        System.out.println(math.multiply(2.5, 3.5));  // Calls double version
    }
}


3) Method with different sequence of parameters:

class Display 
{
    void show(String message, int count) 
    {
        System.out.println("Message: " + message + ", Count: " + count);
    }

    void show(int count, String message) 
    {
        System.out.println("Count: " + count + ", Message: " + message);
    }
}

public class Main 
{
    public static void main(String[] args) 
    {
        Display display = new Display();

        display.show("Hello", 5); // Calls method with (String, int)
        display.show(10, "World"); // Calls method with (int, String)
    }
}



---------------------------------------------------------------------------------------------


5. How is method overriding different from method overloading?
Ans:
	Method Overriding is used in achieving Run time polymorphism.
	In method overriding, methods must share the same method signature, including the same name and same parameters.
	To occur method overriding there must be inheritance.
	The child/sub class provides the specific implementation of the method that is already provided by the super/parent class.
	This implies that overridden methods can have different logic implementations compared to the methods in the parent class.
	The return type must be the same or co-variant (since return type is not part of the signature).

	Example:
	class BankAccount 
	{
    		void interestRate() 
		{
        		System.out.println("Bank Account interest rate: 3%");
    		}
	}

	class SavingsAccount extends BankAccount 
	{
    		void interestRate() 
		{
        		System.out.println("Savings Account interest rate: 5%");
    		}
	}

	class FixedDepositAccount extends BankAccount 
	{
    		void interestRate() 
		{
        		System.out.println("Fixed Deposit interest rate: 7%");
    		}
	}

	public class Main 
	{
    		public static void main(String[] args)
		{
        		BankAccount account;

        		account = new SavingsAccount();
        		account.interestRate();  // Calls SavingsAccount method

	        	account = new FixedDepositAccount();
        		account.interestRate();  // Calls FixedDepositAccount method
    		}
	}


	Method Overloading is used in achieving Compile time polymorphism.
	In method overloading, more than one method shares the same method name with different parameters in the same class.	
	Parameters can be either different number of parameters or different types of parameters or different order of parameters.
	The Return type can be same or different, but we have to change the parameter.
	Example:

	class BankAccount 
	{
    		void deposit(int amount) 
		{
        		System.out.println("Deposited $" + amount + " in cash.");
    		}

    		void deposit(String chequeNumber, int amount) 
		{
        		System.out.println("Deposited $" + amount + " via cheque: " + chequeNumber);
    		}

    		void deposit(String upiID, double amount) 
		{
        		System.out.println("Deposited $" + amount + " via UPI: " + upiID);
    		}
	}

	public class Main 
	{
    		public static void main(String[] args) 
		{
        		BankAccount account = new BankAccount();

        		account.deposit(1000);                 // Cash deposit
        		account.deposit("CHK12345", 5000);     // Cheque deposit
        		account.deposit("user@upi", 2500.50);  // UPI deposit
    		}
	}



-----------------------------------------------------------------------------------------------------

6. Can a subclass overload a method inherited from its superclass?
Ans:
	Yes! A subclass can overload a method inherited from its superclass.
	Overloading means same method name but different parameter lists (number, type, or order of parameters).
	Since method overloading happens within the same class, a subclass can define additional versions of the 
	inherited method with different parameter lists.
	This does not override the superclass method but adds new overloaded versions in the subclass.
	
	Example:

	class Parent 
	{
    		void display() 
		{
        		System.out.println("Display method from Parent class");
    		}
	}

	class Child extends Parent 
	{
    		void display(String message) 
		{
        		System.out.println("Display method from Child class: " + message);
    		}
	}

	public class Main 
	{
    		public static void main(String[] args) 
		{
        		Child obj = new Child();
        
        		obj.display(); // Calls Parent's method (inherited)
        		obj.display("Hello!"); // Calls Child's overloaded method
    		}
	}

Output:
Display method from Parent class
Display method from Child class: Hello!


---------------------------------------------------------------------------------------------


7. Explain the concept of virtual methods in Java.
Ans:
	A virtual method in Java is a method that is resolved at runtime based on the object's actual type, 
	not the reference type. 
	This allows dynamic method dispatch (also known as runtime polymorphism).

	By default, all non-static, non-final methods in Java are virtual methods because they can be overridden in subclasses.

	Working:
	When a method is overridden in a subclass and called using a parent class reference, Java dynamically determines which
	method to execute based on the actual object type at runtime.
	
	Features of Virtual Methods:

	They allow dynamic method dispatch.
	They are resolved at runtime, not compile-time.
	Non-static and non-final methods in Java are virtual by default.
	They help achieve runtime polymorphism.

	Example:

	class Parent 
	{
    		void show() 
		{ 
        		System.out.println("Show method from Parent class");
    		}
	}

	class Child extends Parent 
	{
    		void show() 
		{ 
        		System.out.println("Show method from Child class");
    		}
	}

	public class Main 
	{
    		public static void main(String[] args) 
		{
        		Parent obj = new Child(); // Upcasting (Parent reference, Child object)
        		obj.show(); // Calls Child's method at runtime
    		}
	}


Even though obj is declared as Parent, the overridden show() method from Child is called at runtime because it is a virtual method.


--------------------------------------------------------------------------------------------------------------


8. Discuss the use of the super keyword in achieving polymorphism.
Ans:
	The super keyword in Java is used to refer to the parent class object and helps achieve runtime polymorphism 
	by enabling method overriding and dynamic method dispatch.
	
	super is primarily used for:
	-Calling the Parent Class Constructor (Constructor chaining)
	-Calling the Parent Class Method (To access overridden methods)
	-Accessing Parent Class Fields (To avoid variable name conflicts)

Example for polymorphism:
	When a subclass overrides a method, you can use super.methodName() to call the parent class's version of that method.
	
	class Animal 
	{
    		void sound()
 		{
        		System.out.println("Animal makes a sound");
    		}
	}

	class Dog extends Animal 
	{
        	void sound() 
		{
        		super.sound(); // Calls the overridden method in Animal
        		System.out.println("Dog barks");
    		}
	}

	public class Main 
	{
    		public static void main(String[] args) 
		{
        		Dog d = new Dog();
        		d.sound(); // Calls the overridden method
    		}
	}

	Output:
	Animal makes a sound
	Dog barks


	So here with the help of super we achieved a polymorphism as :

	Without super.sound(), only "Dog barks" would be printed.
	With super.sound(), both the parent and child class behaviors are included.
	This allows subclass behavior to extend rather than replace the parent class behavior.

--------------------------------------------------------------------------------------------------

9. How does Java support polymorphism through interfaces?
Ans:
	Java supports polymorphism through interfaces, allowing multiple classes to implement the same interface 
	and providing different implementations for the methods. 
	This enables dynamic method dispatch and flexibility in code design.	
	
	Example:

	interface Payment 
	{
    		void pay(double amount);
	}


	class CreditCardPayment implements Payment 
	{
 		public void pay(double amount) 
		{
        		System.out.println("Paid $" + amount + " using Credit Card.");
    		}
	}


	class PayPalPayment implements Payment 
	{
    		public void pay(double amount) 
		{
        		System.out.println("Paid $" + amount + " using PayPal.");
    		}
	}

	public class Main 
	{
    		public static void main(String[] args) 
		{
        	        Payment payment1 = new CreditCardPayment();
        		Payment payment2 = new PayPalPayment();
        
        		// Dynamic method dispatch (runtime polymorphism)
        		payment1.pay(100.50);
        		payment2.pay(75.25);
    		}
	}

Output:
Paid $100.5 using Credit Card.
Paid $75.25 using PayPal.


Here the pay() method is called on different objects at runtime, but the reference type is the same (Payment interface).

	Multiple Interfaces and Polymorphism:
	Java allows a class to implement multiple interfaces, which is another way it achieves polymorphism

	interface A 
	{
    		void methodA();
	}

	interface B 
	{
    		void methodB();
	}

	class C implements A, B 
	{
    		public void methodA() 
		{
        		System.out.println("Method A from Interface A");
    		}


    		public void methodB() 
		{
        		System.out.println("Method B from Interface B");
    		}
	}

	public class Main 
	{
    		public static void main(String[] args) 
		{
        		C obj = new C();
        		obj.methodA(); // Calls method from Interface A
        		obj.methodB(); // Calls method from Interface B
    		}
	}

Output:
Method A from Interface A
Method B from Interface B


----------------------------------------------------------------------------------------

	
 10. What is the role of the instanceof operator in polymorphism?
Ans:
	The instanceof operator in Java is used to check whether an object is an instance of a specific class or subclass. 
	It plays an important role in polymorphism by allowing us to determine an object's actual type at runtime before 
	performing operations on it.

	Used in Downcasting: Ensures safe type casting from parent to child class.
	Implements Dynamic Method Resolution: Helps determine the actual class type at runtime.
	Avoids ClassCastException: Prevents invalid type casting.
	Used in Conditional Logic: Enables different behavior based on the object's actual type.

Example:

class Animal 
{
    void makeSound() 
    {
        System.out.println("Some generic animal sound");
    }
}

class Dog extends Animal 
{
    void makeSound() 
    {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal 
{
    void makeSound() 
    {
        System.out.println("Cat meows");
    }
}

public class Main 
{
     public static void main(String[] args) 
     {
        Animal a = new Dog();
        
        if (a instanceof Dog) 
	{
            System.out.println("This is a Dog");
        } 
	else if (a instanceof Cat) 
	{
            System.out.println("This is a Cat");
        }

        a.makeSound(); 
    }
}

Output:
This is a Dog
Dog barks


here instanceof operator helps determine the actual object type (Dog or Cat) before executing logic.
Supports runtime polymorphism by invoking overridden methods dynamically.


--------------------------------------------------------------------------------------------------


 11. Provide an example of polymorphism using the toString method.
Ans:
	In Java, polymorphism allows a subclass to override a method from its superclass. 
	The toString() method is inherited from Object but can be overridden in subclasses to provide a meaningful string representation.

Example:

class Animal 
{
    String name;

    Animal(String name) 
    {
        this.name = name;
    }

    public String toString() 
    {
        return "Animal: " + name;
    }
}

class Dog extends Animal 
{
    String breed;

    Dog(String name, String breed) 
    {
        super(name);
        this.breed = breed;
    }

    public String toString() 
    {
        return "Dog: " + name + ", Breed: " + breed;
    }
}

class Cat extends Animal 
{
    String color;

    Cat(String name, String color) 
    {
        super(name);
        this.color = color;
    }

    public String toString() 
    {
        return "Cat: " + name + ", Color: " + color;
    }
}

public class Test 
{
    public static void main(String[] args) 
    {
        Animal myAnimal = new Animal("Generic Animal");
        Animal myDog = new Dog("Tomy", "Husky");
        Animal myCat = new Cat("Rani", "Black");

        System.out.println(myAnimal); 
        System.out.println(myDog);    
        System.out.println(myCat);    
    }
}

Output:

Animal: Generic Animal
Dog: Tomy, Breed: Husky
Cat: Rani, Color: Black

-------------------------------------------------------------------------------

12. Explain how polymorphism is related to dynamic method dispatch.
Ans:
	Polymorphism in Java allows a method to have different implementations based on the object that invokes it. 
	It enables one interface to be used for multiple implementations, making code more flexible and reusable.

	Dynamic Method Dispatch (DMD) is the mechanism that enables runtime polymorphism.
	It allows method calls to be resolved at runtime rather than compile time.
	This happens when a superclass reference variable refers to a subclass object, 
	and the overridden method in the subclass is executed instead of the superclass method.

Example:
class Parent 
{
    void show() 
    {
        System.out.println("Parent's show() method");
    }
}

class Child extends Parent 
{
    void show() 
    {
        System.out.println("Child's show() method");
    }
}

public class Test 
{
    public static void main(String[] args) 
    {
        Parent obj = new Child(); 
        obj.show();      
    }
}

Output:
Child's show() method


------------------------------------------------------------------------------------------

 13. Discuss the advantages of using polymorphism in software design.

Ans:
Advantages:
	Increases code reusability by allowing objects of different classes to be treated as objects of a common class.
	Improves readability and maintainability of code by reducing the amount of code that needs to be written and maintained.
	Supports dynamic binding, enabling the correct method to be called at runtime, based on the actual class of the object.
	Enables objects to be treated as a single type, making it easier to write generic code that can handle objects of different types.

 	Code Reusability:
	Write Once, Use Anywhere:
	Common methods can be defined in a superclass and reused in multiple subclasses without rewriting code.

	class Animal 
	{
    		void sound() 
		{
        		System.out.println("Animal makes a sound");
    		}
	}
	class Dog extends Animal 
	{
    		void sound() 
		{
        		System.out.println("Dog barks");
    		}
	}

	class Cat extends Animal 
	{
    		void sound() 
		{
        		System.out.println("Cat meows");
    		}
	}


	Flexibility and Maintainability:
	Dynamic Behavior at Runtime:
	The correct method is chosen at runtime, enabling dynamic behavior without changing existing code.
	Easier Maintenance:
	Changes in subclass implementations donâ€™t affect client code, making upgrades seamless.


	Extensibility
	Easy to Extend:
	New subclasses can be added with their own behaviors without modifying existing code, 
	thus following the Open/Closed Principle (open for extension, closed for modification).

	Reduced Coupling
	Loosely Coupled Systems:
	Client code relies on interfaces or abstract classes, not on concrete implementations, leading to better modularity.

	improved Readability and Organization
	Consistent Method Signatures:
	Polymorphism allows methods with common signatures across classes, improving readability and organization of code.
	Example: All subclasses of Shape can have a draw() method, making it intuitive to use.


	Supports Design Patterns
	Polymorphism is fundamental to many design patterns, such as:
	Strategy Pattern: Different algorithms can be swapped at runtime.
	Factory Pattern: Creates objects without specifying the exact class.
	Template Method Pattern: Defines the skeleton of an algorithm, allowing subclasses to override certain steps.


------------------------------------------------------------------------------------------


14. Can a class be both abstract and polymorphic in Java? Justify.
Ans:
	A class can be both abstract and polymorphic in Java. In fact, abstract classes are designed to support polymorphism by allowing 
	subclasses to provide specific implementations of abstract methods while enabling dynamic method dispatch at runtime.

	Abstract Class Enables Polymorphism

	An abstract class in Java:
	Cannot be instantiated directly.
	May contain abstract methods (without implementation) and concrete methods (with implementation).
	Polymorphism occurs when:
	A reference of the abstract class points to an object of a subclass.
	The overridden methods in the subclass are invoked at runtime based on the actual object type (runtime polymorphism).

	ex- 
	abstract class Animal 
	{
    		abstract void sound();  

    		void sleep() 
		{          
        		System.out.println("Animal is sleeping...");
    		}
	}

	class Dog extends Animal 
	{
    		void sound() 
		{
        		System.out.println("Dog barks");
    		}
	}

	class Cat extends Animal 
	{
    		void sound() 
		{
        		System.out.println("Cat meows");
    		}
	}

	public class Main 
	{
    		public static void main(String[] args) 
		{
        		Animal animal;   

        		animal = new Dog();
        		animal.sound();  
        		animal.sleep();  

        		animal = new Cat();
        		animal.sound();  
        		animal.sleep();  
    		}
	}


------------------------------------------------------------------------------------------


15. How does polymorphism contribute to code readability?
Ans:

	Polymorphism enhances code readability by allowing developers to write generic code that can work with objects of different types, reducing 
	redundancy and making the code more concise and easier to understand; essentially, it enables a single interface to handle various object types, 
	leading to cleaner, more organized code with less conditional logic needed to differentiate between different object behaviors. 
	Key points about how polymorphism improves readability:

	Reduces code duplication:
	By using a common interface for different object types, developers can avoid writing repetitive code for similar operations across various classes.
 
	Simplifies complex logic:
	Polymorphism allows for cleaner code by handling different object behaviors dynamically based on their type, minimizing the need for lengthy 
	conditional checks. 

	Improves maintainability:
	When changes are needed to a specific object type, only the relevant class needs to be updated, not the code that interacts with it through the 
	common interface. 

	Enhances abstraction:
	By hiding the internal implementation details of different classes, polymorphism promotes a higher level of abstraction, making the code easier 
	to read and understand. 


------------------------------------------------------------------------------------------


16. Explain the concept of covariant return types in polymorphism.
Ans:

	Covariant return types are a feature in object-oriented programming that allows an overriding method in a subclass to 
	return a more specific type than the method it overrides in the superclass.

	Understanding Covariant Return Types
	Normally, when a subclass overrides a method from its superclass, the method signature (including the return type) 
	should match exactly. However, with covariant return types, the overridden method in the subclass can return a subtype
	of the return type defined in the superclass.

	This feature enhances type safety and eliminates the need for explicit type casting.


	class Animal 
	{
    		Animal getInstance() 
		{
        		return new Animal();
    		}
	}

	class Dog extends Animal 
	{
    		Dog getInstance() 
		{ 
        		return new Dog();
    		}
	}

	public class Main 
	{
    		public static void main(String[] args) 
		{
        		Dog d = new Dog();
        		Animal a = d.getInstance(); 
        		Dog specificDog = d.getInstance(); 
        		System.out.println(specificDog.getClass().getSimpleName());
    		}
}


------------------------------------------------------------------------------------------

17. Discuss the challenges of implementing polymorphism in Java.

Ans:
	Implementing polymorphism in Java can present challenges like potential confusion due to complex class hierarchies, potential 
	performance overhead from runtime method resolution, the risk of naming conflicts with method overloading, and the need for a 
	solid understanding of inheritance and object-oriented principles to use it effectively, potentially leading to bugs if not carefully managed. 

	Key challenges of implementing polymorphism in Java:

	Complexity in large hierarchies:
	When dealing with deep inheritance trees, understanding which method is being called at runtime can become difficult, 
	leading to confusion and potential errors in complex codebases. 

	Performance overhead:
	Runtime polymorphism (method overriding) involves the JVM determining the actual object type at runtime to invoke the appropriate method,
 	which can introduce a slight performance penalty compared to static binding. 

	Naming conflicts with method overloading:
	If not careful, creating multiple overloaded methods with similar parameter types can lead to confusion about which method will be called in a 	specific situation.

 
	Downcasting issues:
	Improper downcasting (casting an object to a more specific type) can lead to ClassCastException errors if the object's actual type does not match 	the cast type. 

	Misuse and over-engineering:
	Using polymorphism excessively can make code harder to read and maintain, as the intent behind multiple methods with the same name 
	might not be clear.
 
	Learning curve:
	Understanding and effectively applying polymorphism requires a good grasp of inheritance, interfaces, and object-oriented principles, 
	which can be challenging for new programmers. 

	How to overcome these challenges:

	Clear naming conventions:
	Use descriptive method names and parameter types to make the intent of overloaded methods clear.
 
	Proper design patterns:
	Employ design patterns like the Strategy Pattern to leverage polymorphism effectively and maintain code modularity. 

	Use interfaces strategically:
	Interfaces can provide a clear contract for different implementations, promoting polymorphism without excessive inheritance complexity. 

	Document code thoroughly:
	Add comments to explain the purpose of polymorphism in your code, especially when using complex inheritance structures. 

	Consider performance implications:
	Be mindful of situations where the performance overhead of runtime polymorphism might be significant and explore alternatives if necessary. 


------------------------------------------------------------------------------------------


18. How can polymorphism be achieved using abstract classes?

Ans:

	Polymorphism is achieved using abstract classes by defining a common interface (set of methods) within the abstract 
	class that can be inherited by various concrete subclasses, allowing objects of different classes to be treated as the 
	same type when using a reference variable of the abstract class, thus enabling the same method call to produce different
 	behaviors depending on the actual object type at runtime; essentially, the abstract class provides a template for 
	subclasses to implement specific functionality while maintaining a consistent interface. 

	Key points about using abstract classes for polymorphism:

	Abstract methods:
	The abstract class defines methods with the "abstract" keyword, which means they don't have implementation details and must
 	be overridden by subclasses. 

	Inheritance:
	Concrete subclasses inherit from the abstract class and provide their own implementations of the abstract methods, allowing 
	for different behaviors based on the specific subclass. 

	Reference variable:
	When creating a reference variable of the abstract class type, you can assign objects of any subclass to it, enabling polymorphism. 

Example:

	abstract class Shape 
	{
    		abstract double calculateArea();
	}

	class Circle extends Shape 
	{
    		double radius;
    		double calculateArea() 
		{
        		return Math.PI * radius * radius;
		}
	}

	class Rectangle extends Shape 
	{
    		double length, width;

		double calculateArea() 
		{
        		return length * width;
    		}
	}



	public class PolymorphismExample 
	{
    		public static void main(String[] args) 
		{
        		Shape[] shapes = {new Circle(), new Rectangle()};
        		for (Shape shape : shapes) 
			{
            			System.out.println("Area: " + shape.calculateArea()); // Polymorphism in action

        		}
    	}

------------------------------------------------------------------------------------------


19. What is the significance of the final keyword in polymorphism?

Ans:
	In the context of polymorphism, the "final" keyword prevents a method from being overridden by subclasses, 
	essentially locking down the behavior of that method and ensuring that the same implementation is used regardless 
	of which class object is being referenced through a polymorphic reference; this is particularly useful when you
 	want to guarantee a specific functionality cannot be altered by inherited classes. 

	Key points about "final" and polymorphism:

	Preventing Overrides:
	When a method is declared as "final", subclasses cannot create their own versions of that method, effectively 
	disabling method overriding. 

	Enforcing Consistent Behavior:	
	By using "final" on methods that should not be modified, you can guarantee that the same functionality is always executed,
 	regardless of which class the object belongs to. 

	Improving Code Stability:
	Restricting method overriding with "final" can help improve code stability by preventing accidental changes to core
	functionalities in derived classes. 


ex-

abstract class Animal {
    abstract void sound();
}

class Dog extends Animal {

    void sound() {
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        final Animal animal = new Dog();  

        animal.sound();  

        // animal = new Cat(); 
    }
}


------------------------------------------------------------------------------------------

 20. Explain the concept of function overloading in polymorphism


Ans:

	Function overloading, within the context of polymorphism, refers to the ability to create multiple functions with 
	the same name but different parameter lists, allowing the compiler to choose the appropriate function based on the 
	arguments provided at the time of the function call - essentially achieving "polymorphism" by providing different 
	behaviors depending on the input data types or number of arguments; this process happens at compile time, making 
	it a form of "compile-time polymorphism.".

 
	Key points about function overloading:

	Same name, different parameters: The core concept is to define multiple functions with the same name but with varying 
	parameter types or numbers.

	Compile-time resolution: The compiler determines which overloaded function to call based on the arguments provided during 
	function invocation, happening at compile time.

ex-
    void add(int a, int b) { 
        cout << a + b << endl;
    }



    void add(double a, double b) { 
        cout << a + b << endl;
    }

	"add" is the overloaded function name, and the compiler would choose the correct "add" 
	function based on whether the arguments passed are integers or doubles. 

	Benefits of function overloading:

	Code readability:
	By using the same name for related operations with different parameter types, the code becomes more intuitive and easier
 	to understand.
 
	Flexibility:
	Allows for different implementations of the same operation depending on the data types involved.
 
	Reduces code duplication:
	By overloading a single function, you can avoid writing separate functions for similar operations with minor variations in argument types. 













 

 
 
 

 
 

.
 

 
 

 
 

